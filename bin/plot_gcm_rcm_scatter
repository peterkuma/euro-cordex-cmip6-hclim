#!/usr/bin/env python3
"""Plot scatter plots of temperature and precipitation for all driving GCMs and RCMs.

Usage: bin/plot_gcm_rcm_scatter INPUT_GCM INPUT_RCM SOURCE... START END OUTPUT

Arguments:

  INPUT_GCM  Input directory with period-season-region statistics for the global models produced by calc_stats (NetCDF).
  INPUT_RCM  The same as INPUT_GCM but for the regional models.
  SOURCE     Regional model source name.
  OUTPUT     Output plot (PDF).
"""

import signal

signal.signal(signal.SIGINT, signal.SIG_DFL)
import sys
from concurrent.futures import ProcessPoolExecutor

import ds_format as ds
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
from lib import io, misc
from matplotlib.gridspec import GridSpec
from matplotlib.lines import Line2D
from matplotlib.patches import FancyArrowPatch

mpl.rc("font", family="Open Sans")
mpl.rc("axes", linewidth=0.3)
mpl.rc("axes", grid=True)
mpl.rc("lines", linewidth=1.2)
mpl.rc("xtick.major", width=0.3)
mpl.rc("ytick.major", width=0.3)
mpl.rc("legend", framealpha=1)
mpl.rc("legend", facecolor="#eeeeee")
mpl.rc("legend", edgecolor="none")
mpl.rc("legend", fancybox=False)
mpl.rc("legend", fontsize=7)
mpl.rc("grid", color="k")
mpl.rc("grid", alpha=0.2)
mpl.rc("grid", lw=0.1)

SEASONS = ["DJF", "JJA"]

REGIONS = [
    "BI",
    "IP",
    "FR",
    "ME",
    "SC",
    "AL",
    "MD",
    "EA",
]

VARS = ["tas", "pr"]

VAR_LABEL = [
    "Temperature",
    "Precipitation",
]

COLORS = [
    "#000000",
    "#8a8a8a",
    "#f40000",
    "#22ad00",
    "#1343ff",
    "#b3b300",
    "#f77400",
    "#e02eff",
    "#086e83",
    "#0ca9c9",
    "#4ad9f6",
]

SOURCE_LETTER = {
    "ERA5": "R",
    "ENS": "E",
    "CNRM-ESM2-1": "C",
    "IPSL-CM6A-LR": "I",
    "MIROC6": "M",
    "NorESM2-MM": "N",
    "EC-Earth3-Veg": "A",
}

SOURCES_OBS = [
    "EUR-12lcc_OBS_obs_r1i1p1f1_ECAD_EOBS30-0e_v1-r1_mon",
    "EUR-12lcc_REAN_rean_r1i1p1f1_ECMWF_CERRA_v1-r1_mon",
    "EUR-12lcc_REAN_rean_r1i1p1f1_ECMWF_CERRA-Land_v1-r1_mon",
]


def source_letter(attrs):
    sid = attrs["source_id"]
    vl = attrs.get("variant_label")
    return (
        "$\\mathsf{"
        + SOURCE_LETTER[sid]
        + ("_%s" % vl[1] if sid == "EC-Earth3-Veg" else "")
        + "}$"
    )


def get_title(d):
    title = misc.get_source_title(ds.attrs(d))
    if title == "EC-Earth3-Veg":
        return title + "/" + ds.attr(d, "variant_label")[:2]
    else:
        return title


def read(input_, source, var, season, region, start, end, index):
    desc = {
        "variable_id": var,
        "season": season,
        "region_code": region,
        "start_year": start,
        "end_year": end,
        "source": source,
    }
    dd = io.read_dataset(
        input,
        desc,
        [var + "_mean"],
        merge=False,
        index=index,
    )
    return dd[0] if len(dd) == 1 else None


def read_all(input, sources, season, region, start, end, index):
    data = {}
    for var in VARS:
        data[var] = {}
        for source in sources:
            d = read(input, source, var, season, region, start, end, index)
            if d is None:
                continue
            data[var][source] = d
    return data


def get_gcm_sources(sources_rcm, data_rcm):
    sources_gcm = []
    for source_rcm in sources_rcm:
        try:
            d = data_rcm[VARS[0]][source_rcm]
        except KeyError:
            source_gcm = None
        else:
            a = ds.attrs(d)
            eid = a["driving_experiment_id"]
            if eid == "evaluation":
                eid = "rean"
            if a["driving_source_id"] == "ERA5":
                source_gcm = "EUR-12lcc_REAN_rean_r1i1p1f1_ECMWF_ERA5_v1-r1_mon"
            else:
                source_gcm = misc.get_source_name(
                    {
                        "source_id": a["driving_source_id"],
                        "experiment_id": eid,
                        "variant_label": a["driving_variant_label"],
                    }
                )
        sources_gcm += [source_gcm]
    return sources_gcm


def plot_panel_data(type_, sources, data, colors, fake=False, ref=None):
    handles = [None] * len(sources)
    labels = [None] * len(sources)
    units_x = ""
    units_y = ""
    for i, source in enumerate(sources):
        try:
            dx = data[VARS[0]][source]
            dy = data[VARS[1]][source]
        except KeyError:
            continue
        x = dx[VARS[0] + "_mean"]
        y = dy[VARS[1] + "_mean"]
        title = get_title(dx)
        ax = ds.attrs(dx, VARS[0] + "_mean")
        ay = ds.attrs(dy, VARS[1] + "_mean")
        x_ref, y_ref = ref if ref is not None else [0, 0]
        x, units_x = misc.convert_pretty_units(x, ax["units"])
        y, units_y = misc.convert_pretty_units(y, ay["units"])
        x_ref, _ = misc.convert_pretty_units(x_ref, ax["units"])
        y_ref, _ = misc.convert_pretty_units(y_ref, ay["units"])

        if type_ in ["gcm", "rcm"]:
            plt.scatter(x - x_ref, y - y_ref, s=0)
            if not fake:
                plt.text(
                    x - x_ref,
                    y - y_ref,
                    source_letter(ds.attrs(dx)),
                    color=colors[i],
                    fontsize=9,
                    ha="center",
                    va="center",
                    zorder=3,
                )
                letter_marker = source_letter(ds.attrs(data[VARS[0]][source]))
                handles[i] = Line2D(
                    [], [], color=colors[i], marker=letter_marker, lw=0
                )
        elif type_ == "obs":
            handles[i] = plt.scatter(
                x - x_ref,
                y - y_ref,
                color=colors[i],
                marker="o",
                s=15,
                zorder=4,
            )
        labels[i] = title
    return handles, labels, units_x, units_y


def plot_arrows(sources_rcm, sources_gcm, data_rcm, data_gcm, colors, ref=None):
    for i, (source_rcm, source_gcm) in enumerate(zip(sources_rcm, sources_gcm)):
        try:
            dxr = data_rcm[VARS[0]][source_rcm]
            dyr = data_rcm[VARS[1]][source_rcm]
            dxg = data_gcm[VARS[0]][source_gcm]
            dyg = data_gcm[VARS[1]][source_gcm]
        except KeyError:
            continue
        xr = dxr[VARS[0] + "_mean"]
        yr = dyr[VARS[1] + "_mean"]
        xg = dxg[VARS[0] + "_mean"]
        yg = dyg[VARS[1] + "_mean"]
        ax = ds.attrs(dxr, VARS[0] + "_mean")
        ay = ds.attrs(dyr, VARS[1] + "_mean")
        x_ref, y_ref = ref if ref is not None else [0, 0]
        xr, units_x = misc.convert_pretty_units(xr, ax["units"])
        yr, units_y = misc.convert_pretty_units(yr, ay["units"])
        xg, units_x = misc.convert_pretty_units(xg, ax["units"])
        yg, units_y = misc.convert_pretty_units(yg, ay["units"])
        x_ref, _ = misc.convert_pretty_units(x_ref, ax["units"])
        y_ref, _ = misc.convert_pretty_units(y_ref, ay["units"])

        # Move the start point slightly in the direction of the end point, so
        # that the arrow does not overlap the marker.
        offset_in = 0.07
        start = np.array([xg - x_ref, yg - y_ref])
        end = np.array([xr - x_ref, yr - y_ref])
        xlim = plt.xlim()
        ylim = plt.ylim()
        bbox = (
            plt.gca()
            .get_window_extent()
            .transformed(plt.gcf().dpi_scale_trans.inverted())
        )
        width_in, height_in = bbox.width, bbox.height
        size = np.array([xlim[1] - xlim[0], ylim[1] - ylim[0]])
        size_in = np.array([width_in, height_in])
        origin = np.array([xlim[0], ylim[0]])
        start_in = (start - origin) / size * size_in
        end_in = (end - origin) / size * size_in
        dir = end_in - start_in
        dir /= np.linalg.norm(dir)
        start_in += dir * offset_in
        start = origin + start_in / size_in * size

        arrow = FancyArrowPatch(
            start,
            end,
            color=colors[i],
            lw=1,
            arrowstyle="-|>",
            mutation_scale=12,
            zorder=1,
        )
        plt.gca().add_patch(arrow)


def plot_panel(
    input_gcm,
    input_rcm,
    sources_rcm,
    sources_obs,
    season,
    region,
    start,
    end,
    index_gcm,
    index_rcm,
    xlabel=True,
    ylabel=True,
    legend=False,
    rel=True,
):
    data_obs = read_all(
        input_rcm, sources_obs, season, region, start, end, index_rcm
    )
    data_rcm = read_all(
        input_rcm, sources_rcm, season, region, start, end, index_rcm
    )
    sources_gcm = get_gcm_sources(sources_rcm, data_rcm)
    data_gcm = read_all(
        input_gcm, sources_gcm, season, region, start, end, index_gcm
    )

    sources_obs = sources_obs[:2]  # Exclude CERRA-Land
    data_obs["pr"][SOURCES_OBS[1]] = data_obs["pr"][
        SOURCES_OBS[2]
    ]  # Set precipitation in CERRA to CERRA-Land

    ref = (
        [data_obs[VARS[i]][SOURCES_OBS[0]][VARS[i] + "_mean"] for i in [0, 1]]
        if rel
        else None
    )

    handles_obs, labels_obs, _, _ = plot_panel_data(
        "obs",
        sources_obs,
        data_obs,
        COLORS,
        ref=ref,
    )
    handles_gcm, labels_gcm, units_x, units_y = plot_panel_data(
        "gcm",
        sources_gcm,
        data_gcm,
        COLORS[len(sources_obs) :],
        ref=ref,
    )
    handles_rcm, labels_rcm, _, _ = plot_panel_data(
        "rcm",
        sources_rcm,
        data_rcm,
        COLORS[len(sources_obs) :],
        fake=True,
        ref=ref,
    )

    plt.text(
        0.5,
        1.03,
        region,
        ha="center",
        fontweight="bold",
        transform=plt.gca().transAxes,
    )

    xlim = plt.xlim()
    ylim = plt.ylim()
    plt.gca().set_xticks(np.arange(np.floor(xlim[0]), np.ceil(xlim[1]) + 1))
    plt.gca().set_yticks(
        np.arange(
            np.floor(ylim[0] / 10) * 10, np.ceil(ylim[1] / 10) * 10 + 10, 10
        )
    )

    xlim = plt.xlim()
    ylim = plt.ylim()
    plt.gca().set_aspect((xlim[1] - xlim[0]) / (ylim[1] - ylim[0]))

    plot_arrows(
        sources_rcm,
        sources_gcm,
        data_rcm,
        data_gcm,
        COLORS[len(sources_obs) :],
        ref=ref,
    )

    if xlabel:
        plt.xlabel(
            "%s (%s)"
            % (
                VAR_LABEL[0] + (" anomaly from OBS" if rel else ""),
                misc.get_pretty_units(units_x),
            )
        )
    if ylabel:
        plt.ylabel(
            "%s (%s)"
            % (
                VAR_LABEL[1] + (" anomaly from OBS" if rel else ""),
                misc.get_pretty_units(units_y),
            )
        )
    if legend:
        plt.gcf().legend(
            handles_obs + handles_gcm,
            labels_obs + labels_gcm,
            loc="upper left",
            bbox_to_anchor=(0.91, 0.885),
            fontsize=9,
            handlelength=1,
        )


if __name__ == "__main__":
    if len(sys.argv) < 3:
        sys.stderr.write(sys.modules[__name__].__doc__)
        sys.exit(1)
    input_gcm = sys.argv[1]
    input_rcm = sys.argv[2]
    sources = sys.argv[3:-3]
    start = int(sys.argv[-3])
    end = int(sys.argv[-2])
    output = sys.argv[-1]

    with ProcessPoolExecutor() as ex:
        index_gcm = io.list_dataset(input_gcm, ex=ex)
        index_rcm = io.list_dataset(input_rcm, ex=ex)

    nseasons = len(SEASONS)
    nregions = len(REGIONS)

    nrows = int(np.ceil(nregions / 2))
    ncols = nseasons * 2

    plt.figure(figsize=(12, 12))
    gs = GridSpec(
        nrows,
        ncols,
        hspace=0.26,
        wspace=0.2,
    )

    for i, season in enumerate(SEASONS):
        for j, region in enumerate(REGIONS):
            row = j // 2 + 1
            col = j % 2 + i * 2 + 1
            plt.subplot(gs[(row - 1) * ncols + col - 1])
            plot_panel(
                input_gcm,
                input_rcm,
                sources,
                SOURCES_OBS,
                season,
                region,
                start,
                end,
                index_gcm,
                index_rcm,
                xlabel=(row == nrows and col == 1),
                ylabel=(row == nrows and col == 1),
                legend=(row == 1 and col == 1),
            )
            # break
        # break

    mar = plt.gcf().subplotpars
    for i, season in enumerate(SEASONS):
        dx = 1 - mar.left - (1 - mar.right)
        x1 = mar.left + (i / nseasons) * dx
        x2 = mar.left + ((i + 1) / nseasons) * dx
        if i == 0:
            x1 -= 0.008
            x2 -= 0.008
        else:
            x1 += 0.008
            x2 += 0.008
        x = 0.5 * (x1 + x2)
        y = 0.91
        line = plt.Line2D(
            [x1 + 0.02, x2 - 0.02],
            [y, y],
            transform=plt.gcf().transFigure,
            color="k",
            zorder=1,
            lw=0.5,
        )
        plt.gcf().add_artist(line)
        plt.gcf().text(
            x,
            y,
            season,
            transform=plt.gcf().transFigure,
            fontsize=14,
            ha="center",
            va="center",
            bbox=dict(facecolor="w", edgecolor="none", pad=10),
            zorder=5,
            fontweight="bold",
        )

    plt.savefig(output, bbox_inches="tight")
    print("-> %s" % output)
