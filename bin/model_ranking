#!/usr/bin/env python3
"""Calculate model ranking based on the mean and variance difference across variables, regions, and seasons.

Usage: bin/model_ranking INPUT SOURCE... START END OUTPUT

Arguments:

  INPUT   Input directory with period-season-region statistics produced by calc_stats (NetCDF).
  SOURCE  Source name.
  START   Start year.
  END     End year.
  OUTPUT  Output plot (PDF).
"""

import signal

signal.signal(signal.SIGINT, signal.SIG_DFL)

import sys

import ds_format as ds
import numpy as np
from lib import io, misc

VARIABLES = [
    "tas",
    "tasmin",
    "tasmax",
    "pr",
    "psl",
]

SEASONS = [
    "ANN",
    "MAM",
    "JJA",
    "SON",
    "DJF",
]


def read(input_, var, names, season, region, source, index):
    desc = {
        "variable_id": var,
        "season": season,
        "region_code": region,
        "start_year": start,
        "end_year": end,
        "source": source,
    }
    dd = io.read_dataset(
        input_,
        desc,
        names,
        merge=False,
        index=index,
    )
    if len(dd) == 1:
        return dd[0]
    elif len(dd) == 0:
        return
    else:
        raise IOError(
            "too many input files for var = %s, season = %s, region = %s, source = %s"
            % (var, season, region, source)
        )


def is_ref(var, d):
    sid = ds.attr(d, "source_id")
    return (var == "psl" and sid == "ERA5") or sid == "EOBS30-0e"


def calc_rank(x, mask):
    x = x.copy()
    x[~mask] = np.nan
    rank = np.argsort(np.argsort(x)).astype(float)
    rank[~mask] = np.nan
    return rank + 1


if __name__ == "__main__":
    if len(sys.argv) < 6:
        sys.stderr.write(sys.modules[__name__].__doc__)
        sys.exit(1)
    input_ = sys.argv[1]
    sources = sys.argv[2:-3]
    start = int(sys.argv[-3])
    end = int(sys.argv[-2])
    output = sys.argv[-1]

    index = io.list_dataset(input_)
    n = len(sources)

    rank_total = []
    rank_region = {}
    rank_var = {}

    regions = list(misc.REGIONS.keys())

    for region in regions:
        for i, var in enumerate(VARIABLES):
            name = var + "_mean_ts"
            for j, season in enumerate(SEASONS):
                dd = []
                z_mean = np.full(n, np.nan, float)
                z_sd = np.full(n, np.nan, float)
                mask = np.full(n, False, bool)
                for i, source in enumerate(sources):
                    d = read(input_, var, [name], season, region, source, index)
                    if d is None:
                        continue
                    if var == "pr" and ds.attr(d, "source_id") == "CERRA":
                        continue
                    eid = ds.attr(d, "experiment_id")
                    z_mean[i] = np.ma.mean(d[name])
                    z_sd[i] = np.ma.std(d[name])
                    mask[i] = eid not in ["obs", "rean"]
                    if is_ref(var, d):
                        i_ref = i
                z_mean_diff = np.abs(z_mean - z_mean[i_ref])
                z_sd_diff = np.abs(z_sd - z_sd[i_ref])
                res = [
                    calc_rank(z_mean_diff, mask),
                    calc_rank(z_sd_diff, mask),
                ]
                rank_total += res
                rank_region[region] = rank_region.get(region, []) + res
                rank_var[var] = rank_var.get(var, []) + res

    rank_total = np.nanmean(rank_total, axis=0)
    rank_region = np.array(
        [np.nanmean(rank_region[region], axis=0) for region in misc.REGIONS]
    )
    rank_var = np.array(
        [np.nanmean(rank_var[var], axis=0) for var in VARIABLES]
    )

    ds.write(
        output,
        {
            "rank_total": rank_total,
            "rank_region": rank_region,
            "rank_var": rank_var,
            "source": sources,
            "region": regions,
            "var": VARIABLES,
            ".": {
                "rank_total": {".dims": ["source"]},
                "rank_region": {".dims": ["region", "source"]},
                "rank_var": {".dims": ["var", "source"]},
                "source": {".dims": ["source"]},
                "region": {".dims": ["region"]},
                "var": {".dims": ["var"]},
            },
        },
    )
    print("-> %s" % output)
